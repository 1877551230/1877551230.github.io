---
layout:     post
title:      java修饰符
subtitle:   
date:       2019-07-06
categories: Java
author:     miracle
catalog: true
tags:
    - Java基础
---

### 代码块
代码块就是一对{},括起来的代码段  
代码块有两种:  
* 1.在类中用代码块括起来的一段代码  
类中的代码块在new 构造函数之前执行
* 2.在方法中用代码块括起来的一段代码
方法中的代码块用于限定某些变量的作用域  
  
类中的代码块的应用场景:  
在构造函数之前需要初始化一些数据的时候

### final关键字  
   
* final可以修饰在成员变量和局部变量  
* final可以修饰在方法上  
* final可以修饰在类上
  
final修饰在变量上,最后的量值,量值不能修改,所以是常量  
 比如:  
  >1.final int i=3;  
     final修饰的变量,只能赋值一次  
   2.final int i;
     i = 10;
     i = 100;//报错

##### 结论:
* final修饰在成员变量上,必须给直接初值,不给初值是语法错,不是执行错  
* final修饰在局部变量上,可以先声明,后给初值,初值只能赋值一次  
* final修饰在方法上,那么这个方法就变成最后的方法,是不能重写的
* final修饰在类上,这个类就是最后的类,final类不能被继承

### 静态
  所有静态相关,都是用static关键字修饰
* 1.static可以修饰成员变量,不能修饰局部变量
* 2.static可以修饰方法
* 3.static可以修饰一段代码,叫做静态块/静态代码块       static{代码段}  
  
  
* static修饰的成员变量:  
开辟空间在方法区  
所以就是一份内存空间,任何方法都可以修改这个静态变量  
一般静态变量做一些**公用或共用的计数,要慎用,尽量把变量做成局部变量**,作用域越小,受干扰的可能性越小  
一般情况下static final共同修饰成员变量  
  
* static修饰方法:  
存储在方法区中 
非静态方法和静态方法在方法区中存储是没有区别的,都是存储在方法区中,但调用上有区别  
**非静态方法被调用,必须先实例化此方法所对应的类的对象,然后用过对象打点来调用这个非静态方法**
**静态方法可以类名直接调用**
如果想频繁的调用一个方法,这个方法不需要操作某个对象的数据时,这个方法最好设置为静态方法  
在静态方法中不能直接使用this,this属于对象,而不属于类  
静态的属于类,而不属于对象  

* static修饰代码块  static{}
代码块就是包含一些代码逻辑,所以静态块还是存储在方法区  
但是静态代码块执行的时机是有区别的  
能写代码逻辑的地方,方法和静态块和代码块中都可以写代码逻辑  
方法中的代码逻辑是否被执行取决于程序员是否调用  
静态代码块在类加载到方法区后,就自动执行代码块  
执行的顺序: 先执行静态代码块-->然后执行类代码块-->然后执行构造函数块  
**在loadclass载入一个类时,还未new对象时,静态代码块就执行**

##### 结论:  
* 静态的方法只能访问静态的变量和静态的方法,即静态的只能访问静态的  
* 非静态的方法可以访问静态的变量和静态的方法,也可以访问非静态的方法和非静态的变量
* 用静态的方法既可以用对象调用(不建议),也可以用类名来调用(建议)
##### 执行顺序
  
例子:
Demo1.java

```java
public class Demo1 {
	Demo2 dd = new Demo2();
	static{
		//可以写代码段
		System.out.println("Demo1.static code");
	}
	public Demo1(){
		System.out.println("Demo1.构造函数");
	}
	
	{
		System.out.println("Demo1.类中的代码块");
		
	}
	
	private static  int age =10;
	private int temp = 10;
	public void testMethod1(){
		age = 100;
		temp = 100;
	}
	public static void testMethod2(){
		age = 1000;
	
	}
	public static void main(String[] args) {
		//1.类加载,Demo1类加载方法区,且开辟了空间age,没有temp空间
		//2.new Demo1()在堆中开辟d1空间,d1中的temp空间也开辟,初值是10,age空间没有
	 Demo1 d1 = new Demo1();
	 //调用testMethod1()把d1中的temp改成100,把方法区中的age也改成了100
	 d1.testMethod1();
	 //从方法区中取出age的数据100
	 System.out.println(age);
	 //从堆空间中的d1中的temp取出的数据是100
	 System.out.println(d1.temp);
	 
	 //没有类加载,直接new对象在堆空间中,d2.temp=10
	 Demo1 d2 = new Demo1();
	 System.out.println(d2.temp);
	 //从方法区中取出的数据,是d1.testMethod方法之前存的100
	 System.out.println(age);
	 
	 Demo1.testMethod2();
	}	
```

Demo2.java

```java
public class Demo2 {
	static{
		System.out.println("Demo2.静态代码块");
	}
	{
		System.out.println("Demo2.类代码块");
	}
	public Demo2(){
		System.out.println("Demo2.构造函数");
	}
}
```

* a.第一个类加载,执行第一个类的静态代码块  
* b.第一个类包含第二个类作为第一个类的属性(注意,new和不new的问题)  
  new:
      >执行第二个类的静态代码块 
      执行第二个类的代码块
      执行第二个类的构造方法
  不new:
       >不加载第二个类

* c.执行第一个类的代码块
    b在c前,执行顺序是a,b,c,d
    c在b前,执行顺序是a,c,b,d
* d.执行第一个类的构造函数

* 如果Demo2继承Demo1,那么先加载父类静态块 --> 加载子类静态块,静态块在加载类的时候就运行了,只加载一次,然后加载父类代码块 --> 父类构造函数 --> 子类代码块 --> 子类构造函数

### 静态+常量 
static final关键字  
一般情况下是公有的静态的final的量  
比如:

```java
public static final int FILE_BLOCK_SIZE = 4*1024*1024;
```

公有的静态的final修饰的量的名字都是大写,且单词间用"_"分隔开,这是一种约定俗成  
static+final的量一般出现在这样的类中
```java
public class SysContant{
	public static final int FILE_BLOCK_SIZE = 4*1024*1024;
	//整个项目中所有用到的固定的常量,且值不需要改变的,都可以放在此类中
	//使用的时候:SysContant.FILE_BLOCK_SIZE来取出即可
}
```

### 访问修饰符:
* public:在本类中,子类中,同包里的类,其他类中
* protected:本类中,子类中,同包里的类
* 默认/friendly/default:本类中,同包的类中
* private:本类中


