---
layout:     post
title:      抽象类和接口
subtitle:   
date:       2019-07-08
categories: Java
author:     miracle
catalog: true
tags:
    - Java面向对象
    - Java基础
---

## 抽象类

 * 如果一个类中,有方法,没有方法体,那么这个方法就是抽象方法,即方法只有声明,没有方法体  
 * 如果一个类中,只要有抽象方法,那么这个类就是抽象类,说明这个类不具体  
  
 * 抽象类也是类,有类就可以放属性和方法(带方法体,不带方法体)  
 * 抽象类中可以放置属性,属性是用来存储数据  
 * 抽象类中,可以放置有方法体的方法,此方法能够完成某个功能  
 * 抽象类中,可以放置没有方法体的方法,这个方法就是抽象方法  
   只要类中有一个抽象方法,这个类就是抽象类  
 * 抽象类是不能实例化对象的,因为抽象类有抽象方法  
 * 程序员不能实例化,并不等于jvm不能实例化对象  

 * 抽象类只能当父类  
 如果在子类中,把所有的抽象方法都补上方法体,那么这个子类就不是抽象类,就可以实例化对象了,同时也可以调用方法  
 如果在子类中,没有把所有的抽象方法补上方法体,那么这个类还是抽象类,满足抽象类的用法  


 * 抽象方法不能用static,final,private修饰  

### 抽象类的应用场景:

 在父类中有一些方法没有方法体,或者没有必要给上方法体,此时把方法做成抽象方法,那么此类就变成抽象类

比如: 
   
 Shape形状类中有一个方法叫做draw()绘制图形的方法  
 Triangle继承自Shape类,draw()方法就可以绘制三角形  
 Retangel继承自Shape类,draw()方法就可以绘制矩形  

 Shape类中的draw方法就应该是抽象方法,因为Shape类不代表具体的形状.所以没办法绘制  
  
把抽象类抽象到极致,所有的方法都没有方法体,此情况不建议做成类,建议做成接口  

## 接口

* 接口中的所有方法都是抽象方法,即没有方法体  
* 接口中可以放属性,但属性默认是public static final的  
* 接口不适合存储数据,更适合做功能  
* 而类适合存储数据和做功能

### 接口的特点

* 接口中的方法和属性都是公有的  
* 接口是不能实例化对象的  
* 必须由子类实现接口,且子类可以实现多个接口,解决java的单继承问题  
* 多个接口用逗号间隔  
* 子类实现接口的关键字implements  
* 直到子类把接口中的所有方法都实现了,才可以实例化子类对象,否则子类是抽象类  
* 接口中可以有属性,但默认的是public static final,不适合存储数据  
* 接口中可以有方法,方法必须都没有方法体,且是公有的,public可以省略  
* 定义接口的关键字interface  
* 接口不能实现接口,但接口可以继承接口,而且可以多继承  ,即接口extends接口1,接口2,....  
* 接口中没有构造方法

### 结论

* 接口更适合放置方法,而不适合存数据  
* 类适合存数据,抽象类和普通类  
* 接口就是对子类功能的规范,子类必须是全部实现接口的方法

### 接口的案例

 1. Person接口:  
  study();  eat();  
  
 2. abstract Commonperson类:  实现了Person接口  
  String name;  int age;  abstract study();   abstract eat();    sleep();  
  
 3. Student类: 继承自CommonPerson
  String stuNo;
  重写:  study(); eat(); 学生的学习方式和吃的方式  
  自己的方法: homework();

4.  Teacher类: 继承自CommonPerson  
  int salary  
  重写: study(); eat(); 老师的学习方式和吃的方式  
  自己的方法: tech();  

为什么要使用接口:
  
1. 用接口可以限定子类,必须实现接口规定的所有方法,以保证项目的功能的完整性
2. 用接口可以实现多态,有接口就一定有继承,而多态是以继承作为基础的

#### 接口例子①

A.java

```java
public interface A {
	public void a1();
	public void a2();

}
```

B.java

```java
public interface B {
	public void b1();
	public void b2();

}
```

C.java

```java
public interface C {
	public void c1();
	public void c2();

}
```

D.java

```java
public interface D extends A,B{
	public void d1();
	public void d2();

}
```

Demo.java

```java
public class Demo1 implements D {

    @Override
	public void a1() {
		// TODO Auto-generated method stub

	}

	@Override
	public void a2() {
		// TODO Auto-generated method stub

	}

	@Override
	public void b1() {
		// TODO Auto-generated method stub

	}

	@Override
	public void b2() {
		// TODO Auto-generated method stub

	}

	@Override
	public void d1() {
		// TODO Auto-generated method stub

	}

	@Override
	public void d2() {
		// TODO Auto-generated method stub

	}

}
```

A,B各有两个抽象方法; D继承了A,B; D本身有两个方法  
Demo实现了D的接口,所以Demo必须重写D中的所有方法

#### 接口例子②

Person.java

```java
public interface Person {
	int i = 3;
	public void study();
	public void eat();

}
```

CommonPerson.java

```java
public abstract class CommonPerson implements Person{
	private String name;
	private int age;
	public CommonPerson(){
		
	}
	public CommonPerson(String name, int age) {
		this.name = name;
		this.age = age;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	public abstract void study();
	public abstract void eat();
	public void sleep(){
		System.out.println("CommonPerson.sleep()");
	}

	
}
```

Student.java

```java
public class Student extends CommonPerson {
	private String stuNo;
	public Student(){
		
	}
	public Student(String name,int age,String stuNo) {
		super(name,age);
		this.stuNo = stuNo;
	}
	public String getStuNo() {
		return stuNo;
	}
	public void setStuNo(String stuNo) {
		this.stuNo = stuNo;
	}
	@Override
	public void study() {
		System.out.println(this.getName()+"Student.study()");
	}
	@Override
	public void eat() {
		System.out.println(this.getStuNo()+"Student.eat()");
	}
	public void homework(){
		System.out.println("Student.homework()");
	}
	
}
```

Teacher.java

```java
public class Student extends CommonPerson {
	private String stuNo;
	public Student(){
		
	}
	public Student(String name,int age,String stuNo) {
		super(name,age);
		this.stuNo = stuNo;
	}
	public String getStuNo() {
		return stuNo;
	}
	public void setStuNo(String stuNo) {
		this.stuNo = stuNo;
	}
	@Override
	public void study() {
		System.out.println(this.getName()+"Student.study()");
	}
	@Override
	public void eat() {
		System.out.println(this.getStuNo()+"Student.eat()");
	}
	public void homework(){
		System.out.println("Student.homework()");
	}
	
}
```

Demo1.java

```java
public class Demo1 {

	public static void main(String[] args) {
		System.out.println("---------------------实例化子类的对象----------------------");
		Student stu1 = new Student("zhangsan",20,"S001");
		stu1.study();
		stu1.eat();
		stu1.sleep();
		stu1.homework();
		Student stu2 = new Student("lisi",21,"S002");
		stu2.study();
		stu2.eat();
		stu2.sleep();
		stu2.homework();
		Teacher tea1 = new Teacher("wanglaoshi",20,100000);
		tea1.study();
		tea1.eat();
		tea1.sleep();
		tea1.teach();
		System.out.println("-------------把实例化完的子类对象赋值给长辈---------------");
	
		CommonPerson cp = stu1;
		cp = stu2;
		cp = tea1;
		
		Person p = cp;
		p = stu1;
		p = stu2;
		p = tea1;
		System.out.println-----------用长辈的对象引用调用方法,引用是谁就调用出哪些方法---------");
		CommonPerson cp1 = stu1;
		cp1.study();
		cp1.eat();
		cp1.sleep();
		Person p1 = tea1;
		p1.study();
		p1.eat();
		
	}

}
```

**结论**  


Person是一个接口,里面有study()和eat()两个方法  
CommonPerson是一个抽象类实现自Person,里面有sleep()方法,未实现的study()和eat()方法,因为此时具体需求还未确定,所以并未重写接口里的方法,有自己的sleep()方法  
Student是一个类,继承自CommonPerson实现自Person,它实现了接口里的所有抽象方法,并且有自己的homework()方法  
Teacher是一个类,继承自CommonPerson实现自Person,它实现了接口里的所有抽象方法,并且有自己的salary()方法  


用长辈的对象引用调用方法时,引用是谁的就调出哪些方法.如:Person只有study()和eat()方法,它的实例化对象p只能调用study和eat方法,并且调用的是实例化的子类重写后的方法

