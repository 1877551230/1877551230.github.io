---
layout:     post
title:      IO输入输出流
subtitle:   
date:       2019-07-18
categories: Java
author:     miracle
catalog: true
tags:
    - JavaAPI
---

* content
{:toc}
## IO作用
input输入 output输出
所有往内存中送数据的都是输入  
所有从内存中出数据的都是输出  

* 能用java.io包的api方法操作的输入输出  
内存-->外存(硬盘,优盘,光盘) 本地流输出  
内存<--外存                 本地流输入  
 结合Socket网络编程  
内存-->网络上 网络流输出  
内存<--网络上 网络流输入  
**网络流案例:**  
 计算机A和远程计算机B  
 从计算机B的计算机上下载文件到计算机A上  
  1. 先从B中的硬盘上本地流输入,把硬盘上的文件读入到内存
  2. 把内存中的文件数据网络流输出,把内存的数据输出到网络上
  3. 计算机A网络流输入,把网络上的文件数据读入到内存
  4. 把内存中的数据,本地流输出到A硬盘
 上传文件的过程和下载相反

* 不能用java.io包操作的流
内存-->显示器  
内存-->CPU  
内存<--CPU  

## 数据持久化

 数据长时间保留在硬盘上  
 数据长时间保存在数据库,数据库的本质是以数据文件的方式持久化到硬盘上  

- 在硬盘中的实际体现出来的是文件和目录
 java中提供了一个java.io.File类,用来操作文件的目录信息和文件的信息,就是不能操作文件的内容  

- 根据文件的内容操作
 * 字节流:对文件的内容读写用字节的方式操作
 * 字符流:对文件的内容读写用字符(ASCII)的方式操作,但是本质底层还是用的字节流

## java.io.File类

用户表示文件和目录,和文件内容无关  
**注意**:在不同的操作系统上,对于目录的间隔符的区分  
 windows: C:\\aa\\bb\\cc.txt  
 linux: /home/usr/cc.txt  
 在java中对路径的分隔符的表示
 * windows: C:\\aa\\b\\c.txt 或C:/aa/bb/cc.txt
 * linux:/home/aa/bb/c.txt
 如果想兼容windows和linux  
 "aa"+File.separator+"bb"+File.separator+"cc.txt"

### File的api

- **构建File类对象**
1. File(String filePath);  
2. File(File parent,String child);  
3. File(String parentName,String child);
```java
File parent = new File("D:\\aa");//String parent = "d:\\aa";
File child = new File(parent, "aa.txt");
```
- **isFile()**判断是否是文件
- **isDiretory()**判断是否是目录
- **length()**获取文件的长度
- **exists()**判断文件或目录是否存在
- **createNewFile()**创建一个空文件,返回值是boolean,如果指定的文件不存在就创建文件并返回true,如果指定的文件存在就返回false
- **delete()**删除文件
 如果File表示一个目录,删除的时候,要保证目录必须是空
```java
public void testMethod10() {
		File file = new File("D:/aa");
		deleteFile(file);
	}

	private void deleteFile(File file) throws RuntimeException {
		if (file == null) {
			// System.out.println("file为null,不能删除");
			throw new RuntimeException("file为null,请指定具体的目录或文件");
		}
		if (file.isDirectory()) {
			// 指定的file为目录
			// 返回指定目录中的所有文件和目录
			File[] files = file.listFiles();
			// 遍历files,有可能是目录,也有可能是文件
			for (File f : files) {
				// 递归调用自己
				deleteFile(f);
			}
		}
		// 说明是文件,直接删了
		file.delete();
	}

```
- **mkdir()**创建目录
- **mkdirs()**创建多个目录
- **listFiles()**返回指定目录中所有的文件和目录
- **listFiles(FileFilter)**返回指定目录中的部分文件和目录,用FileFilter设定筛选条件
- **listFiles(FilenameFilter)**返回指定目录中的部分文件和目录,用FilenameFileFilter设定筛选条件

### 总结
1. 只能操作文件或目录的信息
2. 就是不能操作文件的内容


## RandomAccessFile类

- 可以操作文件的内容
- 按照字节操作,字节流  
- read读和write写都是此类中的方法
- 能够通过seek方法可以随意移动或改动文件的指针  

RandomAccessFile类对文件的随机访问有两种模式
1.只读模式  
2.读写模式  

### 创建对象  
- **RandomAccessFile(File file,String mode);**  
 创建从中读取和向其中写入的随机访问流  
 文件通过file指定,模式通过String指定  
```java
	RandomAccessFile raf1 = new RandomAccessFile(new File("D:/aa/aa.txt"),"r");
	RandomAccessFile raf2 = new RandomAccessFile("D:/aa/aa.txt","rw");
```
- **RandomAccessFile(String name,String mode);**  
 创建从中读取和向其中写入的随机访问流  
 文件通过String指定,模式通过String指定  
- mode的取值  
  "r"只读模式 read  
  "rw"读写模式 read write  

### 写入操作  
* void write(int d);  
 此方法会根据当前指针所在的位置写入一个字节,只能使用整型的低8位  
* void write(byte[] d)  
 此方法会根据当前指针所在的位置处写出一组字节  
```java
RandomAccessFile raf1 = new RandomAccessFile(new File("D:/aa/aa.txt"),"rw");
raf1.write("hello world".getBytes());
```
* void write(byte[] d,int offset,int len);  
 将len个字节从指定的byte数组写入文件,并从偏移量offset处开始
```java
RandomAccessFile raf1 = new RandomAccessFile(new File("D:/aa/aa.txt"),"rw");
raf1.write("hello world".getBytes(),1,6);
```

### 读取操作
* int read()  
 从文件中度取出一个byte字节,填充到整型的低8位,如果返回-1,表示读取到文件的末尾,EOF end of file
* int read(byte[] b)
 从指针指向的位置开始读取若干字节,存储到字节数组中  
 将读取到的字节按照顺序放在字节数组的相对应的位置  
 返回值为读取到的字节数,也可以说成是读取到的长度  
 返回值为-1,则读取到文件的末尾
```java
RandomAccessFile raf1 = new RandomAccessFile(new File("D:/aa/aa.txt"),"r");
byte[] buf = new byte[3];
int len = raf1.read(buf);//每次读三字节
```
* int read(byte[] d,int offset,int len)
 将最多len个数据字节从文件中读入到byte数组中,并从偏移量offset开始读
```java
RandomAccessFile raf1 = new RandomAccessFile(new File("D:/aa/aa.txt"),"r");
byte[] buf = new byte[5];
int len = raf1.read(buf,0,3);//每次读5字节,从0开始,读三个
```
* void getFilePointer()
 返回此文件的当前偏移量
* void seek(long position)
 设置到此文件开头0到文件指针的偏移量,在该位置发生下一个读取或写入操作
```java
public void testMethod9()throws Exception{
		RandomAccessFile raf1 = new RandomAccessFile(new File("D:/aa/aa.txt"),"r");
		System.out.println(raf1.getFilePointer());
        raf1.seek(4);//设置偏移量到4
        int d = raf1.read();
        System.out.println(d);
		raf1.seek(1);
		d=raf1.read();
		
		System.out.println(d);
		
		raf1.close();
		
	}
```
* int skipBytes(int n)
 用此方法可以跳过一些少量的字节,只可以正数,负数相当于0
```java
public void testMethod10()throws Exception{
		RandomAccessFile raf1 = new RandomAccessFile(new File("D:/aa/aa.txt"),"r");
		System.out.println(raf1.getFilePointer());
        raf1.seek(4);
        int d = raf1.read();
        System.out.println(d);
		raf1.skipBytes(-100);//-100相当于0 负数相当于0
		d=raf1.read();
		
		System.out.println(d);
		
		raf1.close();
	}
```


### 结论
每次读完或者写完,指针自动指向下一个字节