---
layout:     post
title:      java封装和继承
subtitle:   
date:       2019-07-06
categories: Java
author:     miracle
catalog: true
tags:
    - Java面向对象
    - Java基础
---
### this用法
this有两种形式的用法:
1. this.       访问当前对象的属性或方法
2. this(参数列表)     调用本类的其他构造函数
this指的是当前对象  
**如何判断this指向的是哪个对象?**  
this在哪个方法里,这个方法被哪个对象调用,那么this就指向那个对象,这个原则适用于this.  不适用this();
### 代码块
代码块就是一对{},括起来的代码段  
代码块有两种:  
* 1.在类中用代码块括起来的一段代码  
类中的代码块在new 构造函数之前执行
* 2.在方法中用代码块括起来的一段代码
方法中的代码块用于限定某些变量的作用域  
  
类中的代码块的应用场景:  
在构造函数之前需要初始化一些数据的时候

### final关键字  
   
* final可以修饰在成员变量和局部变量  
* final可以修饰在方法上  
* final可以修饰在类上
  
final修饰在变量上,最后的量值,量值不能修改,所以是常量  
 比如:  
  >1.final int i=3;  
     final修饰的变量,只能赋值一次  
   2.final int i;
     i = 10;
     i = 100;//报错

##### 结论:
* final修饰在成员变量上,必须给直接初值,不给初值是语法错,不是执行错  
* final修饰在局部变量上,可以先声明,后给初值,初值只能赋值一次  
* final修饰在方法上,那么这个方法就变成最后的方法,是不能重写的
* final修饰在类上,这个类就是最后的类,final类不能被继承

### 静态
  所有静态相关,都是用static关键字修饰
* 1.static可以修饰成员变量,不能修饰局部变量
* 2.static可以修饰方法
* 3.static可以修饰一段代码,叫做静态块/静态代码块       static{代码段}  
  
  
* static修饰的成员变量:  
开辟空间在方法区  
所以就是一份内存空间,任何方法都可以修改这个静态变量  
一般静态变量做一些**公用或共用的计数,要慎用,尽量把变量做成局部变量**,作用域越小,受干扰的可能性越小  
一般情况下static final共同修饰成员变量  
  
* static修饰方法:  
存储在方法区中 
非静态方法和静态方法在方法区中存储是没有区别的,都是存储在方法区中,但调用上有区别  
非静态方法被调用,必须先实例化此方法所对应的类的对象,然后用过对象打点来调用这个非静态方法
静态方法可以类名直接调用
如果想频繁的调用一个方法,这个方法不需要操作某个对象的数据时,这个方法最好设置为静态方法  
在静态方法中不能直接使用this,this属于对象,而不属于类  
静态的属于类,而不属于对象  

* static修饰代码块  static{}
代码块就是包含一些代码逻辑,所以静态块还是存储在方法区  
但是静态代码块执行的时机是有区别的  
能写代码逻辑的地方,方法和静态块和代码块中都可以写代码逻辑  
方法中的代码逻辑是否被执行取决于程序员是否调用  
静态代码块在类加载到方法区后,就自动执行代码块  
执行的顺序: 先执行静态代码块-->然后执行类代码块-->然后执行构造函数块  
**在loadclass载入一个类时,还未new对象时,静态代码块就执行**

##### 结论:  
* 静态的方法只能访问静态的变量和静态的方法,即静态的只能访问静态的  
* 非静态的方法可以访问静态的变量和静态的方法,也可以访问非静态的方法和非静态的变量
* 用静态的方法既可以用对象调用(不建议),也可以用类名来调用(建议)
##### 执行顺序
  
例子:
Demo1.java

```java
public class Demo1 {
	Demo2 dd = new Demo2();
	static{
		//可以写代码段
		System.out.println("Demo1.static code");
	}
	public Demo1(){
		System.out.println("Demo1.构造函数");
	}
	
	{
		System.out.println("Demo1.类中的代码块");
		
	}
	
	private static  int age =10;
	private int temp = 10;
	public void testMethod1(){
		age = 100;
		temp = 100;
	}
	public static void testMethod2(){
		age = 1000;
	
	}
	public static void main(String[] args) {
		//1.类加载,Demo1类加载方法区,且开辟了空间age,没有temp空间
		//2.new Demo1()在堆中开辟d1空间,d1中的temp空间也开辟,初值是10,age空间没有
	 Demo1 d1 = new Demo1();
	 //调用testMethod1()把d1中的temp改成100,把方法区中的age也改成了100
	 d1.testMethod1();
	 //从方法区中取出age的数据100
	 System.out.println(age);
	 //从堆空间中的d1中的temp取出的数据是100
	 System.out.println(d1.temp);
	 
	 //没有类加载,直接new对象在堆空间中,d2.temp=10
	 Demo1 d2 = new Demo1();
	 System.out.println(d2.temp);
	 //从方法区中取出的数据,是d1.testMethod方法之前存的100
	 System.out.println(age);
	 
	 Demo1.testMethod2();
	}	
```

Demo2.java

```java
public class Demo2 {
	static{
		System.out.println("Demo2.静态代码块");
	}
	{
		System.out.println("Demo2.类代码块");
	}
	public Demo2(){
		System.out.println("Demo2.构造函数");
	}
}
```

* a.第一个类加载,执行第一个类的静态代码块  
* b.第一个类包含第二个类作为第一个类的属性(注意,new和不new的问题)  
  new:
      >执行第二个类的静态代码块 
      执行第二个类的代码块
      执行第二个类的构造方法
  不new:
       >不加载第二个类

* c.执行第一个类的代码块
    b在c前,执行顺序是a,b,c,d
    c在b前,执行顺序是a,c,b,d
* d.执行第一个类的构造函数

### 静态+常量 
static final关键字  
一般情况下是公有的静态的final的量  
比如:
```java
public static final int FILE_BLOCK_SIZE = 4*1024*1024;
```

公有的静态的final修饰的量的名字都是大写,且单词间用"_"分隔开,这是一种约定俗成  
static+final的量一般出现在这样的类中
```java
public class SysContant{
	public static final int FILE_BLOCK_SIZE = 4*1024*1024;
	//整个项目中所有用到的固定的常量,且值不需要改变的,都可以放在此类中
	//使用的时候:SysContant.FILE_BLOCK_SIZE来取出即可
}
```

### 方法的重载:
在同一个类内,在相同的方法的名字,但参数的个数和类型不同,跟方法的返回值无关  
 
比如:都是求和功能  
* 此类是重载

```java
public class clac{
	public int sum(int a,int b){
		return a+b;
	}
public float sum(float a,float b){
	return a+b;
	}
}
```

使用:  
clac c = new clac();
int result1 = c.sum(1,2);
float result2 = c.sum(1.2F,3)  

  
* 此类不是重载

```java
public class clac{
	public int sum1(int a,int b){
		return a+b;
	}
public float sum2(float a,float b){
	return a+b;
	}
}
```
  
使用:  
clac c = new clac();
int result1 = c.sum1(int a,int b);
float result2 = c.sum2(float a,int b);
  
#### 重载的应用
 功能相似,但功能有一些细微差异  
 封装:  
   把私有的数据封装,用公有的getter and setter和构造存储数据和取出数据,适合存储数据
   类中只封装功能,不封装数据,适合做功能
  类中封装的就是属性和方法

## 继承
继承必须以封装为基础  ,实现继承就是为了代码的重用, 继承充分展现了代码的可复用性  
因为现实世界有很多的继承关系,所以把现实世界的物或事转换到计算机中,就需要java的继承,同时增加了类和类的关系  
此关系很单一,就是继承关系  
  
所有的非Object类都有父类,如果没有写extends关键字,实际上默认继承了Object  
java的根类是Object类
  
继承是通过extends关键字类实现的,extends后的父亲只能有一个,所以java是单继承  

有了java的继承,好处就是代码重用,坏处就是类和类之间的关系复杂了

#### 继承中几个容易混淆的概念:
* 子类能够继承长辈的非私有的东西(属性和方法)
* 子类不是拥有长辈的东西,只是子类对长辈的东西有访问性
* 类里的东西就是本类自己的
  
有了继承之后,同样要考虑数据的存储问题,对象的数据该如何存取  
	在子类中利用继承的可访问性调用长辈的方法,用长辈的自己的方法来操作长辈类自己对象中的私有属性

### super关键字
super(参数列表)
* 参数列表可以是0个,也可以是多个  
* 调用父类构造,且super(参数列表)只能写在子类构造的第一条语句,super()调用的是父亲无参构造,如果不写,系统会自动添上

super. 用来掉用父亲的方法或属性.     前提,父类是否允许子类调用
##### 结论
  做继承是为了复用长辈中的内容(属性和方法), 即就在子类中使用长辈中的内容(属性和方法)  
  所以继承的
      优点:可以使用长辈中的内容
      缺点:增加了类和类之间的复杂关系
      	   如果继承的层次越多,子类中可访问的内容就越来越多,但是子类并不都需要
  在开发中,少用继承,多用组合  
  什么时候用继承:
  - 继承的层次不要太多
  - 要使用多态的时候必须是以继承作为前提的

  什么时候使用组合:
  - 想要获取别的类中的方法和属性的时候可以用组合
  - 现用,现组合

组合的方式有两种:
1. 在类中放置属性/组合属性

```
public class xx{
	//组合另一个类的对象
	private Test test;
	public void method(){
		//在此方法中可以使用或操作test对象中的数据
	}
}
```

2. 在类的方法中组合数据

```
public class yy{
	public void method(Test test){
		//在此方法中使用或操作test对象中的数据
	}
}
```

* 组合是has a的关系,有一个  
 上面的方式一:xx类有一个test对象  
 上面的方式二:yy类的method方法有一个test对象
* 继承是is a的关系,是一个
 Student is a CommonPerson 学生是一个普通人
 Teacher is a CommonPerson 老师是一个普通人

想要获取别的类中的数据:  
1.用继承  
2.用组合  

#### 继承中的重写
跨类且继承,子类重写父类的方法  
方法重写的若干要求:
* 1.子类重写的方法的权限修饰符必须大于等于父类
* 2.子类中重写的方法的返回值类型必须小于等于父类
* 3.如果父类的方法的返回值是基本数据类型或void,那么子类在重写方法的时候,返回类型必须一致
* 4.如果父类的返回类型是最终类(final),那么子类在重写方法的时候返回类型必须一致
一般情况下,父类中的要重写的方法的声明跟子类方法的声明一样即可
#### 重写和重载的区别
* 重载:
 在类内,相同的方法的名称,但参数的个数和类型不同
* 重写:
 跨类且继承,子类把长辈的方法的方法体覆盖

#### 访问修饰符:
* public:在本类中,子类中,同包里的类,其他类中
* protected:本类中,子类中,同包里的类
* 默认/friendly/default:本类中,同包的类中
* private:本类中

#### 构造函数在有继承时的调用

使用下面例子时,修改子类和父类构造里的super的参数列表,可以看到效果

例子  :
  
CommenPerson.java

```java
public class CommenPerson {
	private String name;
	private int age;
	public CommenPerson(){
		System.out.println("CommenPerson.不带参数构造");
	}
	
	public CommenPerson(String name, int age) {
		super();
		this.name = name;
		this.age = age;
		System.out.println("Student.带参数构造");
	}

	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	public void study(){
		System.out.println("CommenPerson.study()");
	}
	public void eat(){
		System.out.println("CommenPerson.eat()");
	}

}
```

Student.java

```java
public class Student extends CommenPerson{
	
	private String stuNo;
	public Student(){
		super();//调用父类的构造函数,如果没有写会自动添加,必须写在子类构造的第一条语句
		System.out.println("Student.不带参数构造");
	}
	
	public Student(String name,int age,String stuNo) {
		super(name,age);
		this.stuNo = stuNo;
		System.out.println("Student.带参数构造");
	}

	public String getStuNo() {
		return stuNo;
	}
	public void setStuNo(String stuNo) {
		this.stuNo = stuNo;
	}
	
	public void homework(){
		System.out.println("Student.homework");
		super.study();
	}
}
```

Teacher.java
```java
public class Teacher extends CommenPerson{
	
	private int salary;
	public Teacher(){
		super();
		System.out.println("Teacher.constructor");
	}
	
	public Teacher(String name,int age,int salary) {
		super(name,age);
		this.salary = salary;
	}

	public int getSalary() {
		return salary;
	}
	public void setSalary(int salary) {
		this.salary = salary;
	}
	public void study(){
		System.out.println("Teacher.study()");
	}
	public void eat(){
		System.out.println("Teacher.eat()");
	}
	public void tech(){
		System.out.println("Teacher.tech()");
	}
```

Demo1.java

```java
public class Demo1 {

	public static void main(String[] args) {
		Student stu1 = new Student("zhangsan",20,"s001");
		Teacher tea1 = new Teacher();
	}
}

```
在Student的有参构造函数里,把super()改成无参或者不写super,会去调用父类的无参构造方法,会导致传入参数的值一直是null或0,不能传值

**结论**

1. 在Student stu1,且Student继承于commonPerson时,loadclass student类和commonPerson类进入方法区
2. new Student();时 进入Student的构造函数,此时看构造函数第一个语句,如果该构造函数有super(),则super()先调用父类的无参构造函数,如果没有写会自动添加super();如果有super(参数列表),会先去调用父类对应参数列表的构造,执行完父类构造,父类对象出现了,在堆中,name=null,age=0;    
3. 执行完父类构造后,会自动回子类构造,执行子类构造,执行完毕,stuNo=null,子类对象在堆中出现
4. 如果第二部是 new Student("zhangsan",20,"s001");会先调用Student中的对应含有此参数的构造函数,然后看构造函数中的super(),然后根据参数对应去调用父类的构造函数.

总结:  
在new一个新对象时,先调用该类对应的构造函数,然后在构造函数里按顺序执行,第一行是super,必定先去父类调用对应的构造方法
