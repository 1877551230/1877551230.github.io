---
layout:     post
title:      web限制ip登录注册
subtitle:   
date:       2019-08-13
categories: Java
author:     miracle
catalog: true
tags:
    - JavaWeb
---

* content
{:toc}

## 工作原理图

[图](https://github.com/1877551230/1877551230.github.io/blob/master/img/%E7%94%A8%E6%88%B7%E6%A1%88%E4%BE%8B%E6%95%B0%E6%8D%AE%E6%B5%81%E8%BD%AC%E5%9B%BE.png?raw=true)

 * [jdbc基础参考](gitee.q1877551230.io/JDBC)

## 限制ip

```xml
 <servlet>
    <servlet-name>SysInitServletName</servlet-name>
    <servlet-class>cn.tedu.servlet.SysInitServlet</servlet-class>
    <init-param>
      <param-name>ipRange</param-name>
      <param-value>10.8.38.1-10.8.38.100</param-value>
    </init-param>
    <init-param>
      <param-name>encoding</param-name>
      <param-value>UTF-8</param-value>
    </init-param>
    <load-on-startup>0</load-on-startup>
  </servlet>
```

此xml有load-on-starup,此servlet在服务器加载的时候就加载  
<init-param>在<servlet>中,变量只在此servlet生效



```xml
 <context-param>
    <param-name>globalIpRange</param-name>
    <param-value>10.8.38.1-10.8.38.100</param-value>
  </context-param>
  <context-param>
    <param-name>globalEncoding</param-name>
    <param-value>UTF-8</param-value>
  </context-param>
```

此xml功能同上,但此<context-param>在<web-app>中,是全局变量,对整个项目生效



```xml
  <servlet>
    <servlet-name>IPLimitedServletName</servlet-name>
    <servlet-class>cn.tedu.servlet.IPLimitedServlet</servlet-class>
  </servlet>
  <servlet-mapping>
    <servlet-name>IPLimitedServletName</servlet-name>
    <url-pattern>/ip</url-pattern>
  </servlet-mapping>
  <servlet>
```

此servlet是对ip进行限制  

```xml
<welcome-file-list>
    <welcome-file>ip</welcome-file>
</welcome-file-list>
```

当有人访问时,IPLimitedServlet生命周期开始,SysInitServlet在加载时生命周期就开始


SysInitServlet.java

```java
public class SysInitServlet extends HttpServlet {

	@Override
	public void destroy() {
		// TODO Auto-generated method stub
		super.destroy();
	}

	@Override
	public void init() throws ServletException {
		//读取全局数据
		String ipRange=this.getServletContext().getInitParameter("globalIpRange");
		String encoding=this.getServletContext().getInitParameter("globalEncoding");
		CommonValue.ipRange=ipRange;
		CommonValue.encoding=encoding;
		System.out.println(CommonValue.ipRange);
		System.out.println(CommonValue.encoding);
		//读取局部数据
		/*String ipRange=this.getInitParameter("ipRange");
		String encoding=this.get
		InitParameter("encoding");
		CommonValue.ipRange=ipRange;
		CommonValue.encoding=encoding;
		System.out.println(CommonValue.ipRange);
		System.out.println(CommonValue.encoding);*/
	}

	@Override
	public void init(ServletConfig config) throws ServletException {
		System.out.println("init(ServletConfig)");
				//读取全局数据
				String ipRange=config.getServletContext().getInitParameter("globalIpRange");
				String encoding=config.getServletContext().getInitParameter("globalEncoding");
				CommonValue.ipRange=ipRange;
				CommonValue.encoding=encoding;
				System.out.println(CommonValue.ipRange);
				System.out.println(CommonValue.encoding);
				//读取局部数据
				/*String ipRange=this.getInitParameter("ipRange");
				String encoding=this.getInitParameter("encoding");
				CommonValue.ipRange=ipRange;
				CommonValue.encoding=encoding;
				System.out.println(CommonValue.ipRange);
				System.out.println(CommonValue.encoding);*/
	}
}
```

```java
public class CommonValue {	
	public static String ipRange="";
	public static String encoding="";

}
```

上面有两种方式获得ipRange,一种是读取全局数据,另一种是读取局部数据,读取的方式不一样,两种方式对应上面两种xml的写法,当有init(ServletConfig config)时调用该方法,无参数方法不调用.把得到的IPRange和encoding存给CommonValue.java.

以上的代码都是在服务器加载时就工作

然后写限制ip的servlet具体业务逻辑

```java
@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		String ipRange=CommonValue.ipRange;
		String[] ips=ipRange.split("-");
		int ip1=Integer.parseInt(ips[0].substring(ips[0].lastIndexOf(".")+1));
		int ip2=Integer.parseInt(ips[1].substring(ips[1].lastIndexOf(".")+1));;
		System.out.println(ip1+" "+ip2);
		//获取客户端访问的真实ip
		String realIp=req.getRemoteAddr();
		int clientIp=Integer.parseInt(realIp.substring(realIp.lastIndexOf(".")+1));
		System.out.println("realIp="+realIp);
		if(clientIp>ip1&&clientIp<ip2){
			resp.sendRedirect("login.html");//如果符合就重定向到登录界面
		}else{
			PrintWriter out=resp.getWriter();
			out.append("u r not qulify to read,ur ip="+realIp);
			out.close();
		}
	}

```


## 登录

先写xml,web.xml在服务器启动时就加载到内存,当请求login时,找到UserLoginServlet.class并实例化对象  


```xml
<servlet>
    <servlet-name>UserLoginServletName</servlet-name>
    <servlet-class>cn.tedu.servlet.UserLoginServlet</servlet-class>
  </servlet>
  <servlet-mapping>
    <servlet-name>UserLoginServletName</servlet-name>
    <url-pattern>/login</url-pattern>
  </servlet-mapping>
```

UserLoginServlet.java

```java
@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		//获取前端提交的数据
		String uname=req.getParameter("userName");
		String upwd=req.getParameter("userPassword");
		User user=new User();
		user.setName(uname);
		user.setPassword(upwd);
		//调用业务
		UserService userService=new UserServiceImpl();
		boolean flag=userService.login(user);
		//根据业务的返回结果做响应
		if(flag){
			resp.sendRedirect("success.jsp");
		}else{
			resp.sendRedirect("login.jsp");
		}
	}
```

接下来调用业务层
UserService.java(业务接口)

```java
public interface UserService {
	//登录的业务接口方法
	public boolean login(User user);

	public boolean register(User user);

}
```

具体业务逻辑

```java
public class UserServiceImpl implements UserService {
	private UserDao userDao=new UserDaoImpl();
	@Override
	public boolean login(User user) {
		boolean flag=false;
		int id=userDao.login(user);//调用数据库
		if(id>0){
			flag=true;
		}
		return flag;
	}
}
```

通过逻辑代码调用数据库的数据
数据库访问层接口
userDao.java

```java
public interface UserDao {
	//登陆的数据库方法
	public int login(User user);
	//注册的数据库方法
	public int register(User user);
}
```


登录操作实现
useDaoImpl.java

```java
public class UserDaoImpl implements UserDao {

	@Override
	public int login(User user) {
		int id=0;
		try {
			String sql = "select id from t_user where username=? and userpassword=?";
			Object[] params = new Object[] { user.getName(), user.getPassword() };
			List<User> users = CommonDao.executeQuery(User.class, sql, params);
			if (users != null && users.size() == 1) {
				id = users.get(0).getId();
			} 
		} catch (Exception e) {
			e.printStackTrace();
		}
		return id;
	}
```

### 总结
数据的轮回如下

 浏览器-->Servlet-->业务逻辑层-->数据访问层(数据)  
 数据访问层(数据)-->业务逻辑层-->Servlet-->浏览器  
最终响应在浏览器上

## 注册

同登录,在创建Servlet类时可以直接创建Servlet对象,会自动在web.xml生成相应的配置

```xml
  <servlet>
    <servlet-name>UserRegisterServlet</servlet-name>
    <servlet-class>cn.tedu.servlet.UserRegisterServlet</servlet-class>
  </servlet>
  <servlet-mapping>
    <servlet-name>UserRegisterServlet</servlet-name>
    <url-pattern>/register</url-pattern>
  </servlet-mapping>
```

web.xml在服务器启动时就加载到内存,在请求register时,找到register同名的Servlet,找到类通过反射实例化对象  

UserRegisterServlet.java

```java
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		//1.获取注册的数据
		String uname=request.getParameter("userName");
		String upwd=request.getParameter("userPassword");
		String uage=request.getParameter("age");
		String uaddress=request.getParameter("address");
		User user=new User();
		user.setName(uname);
		user.setPassword(upwd);
		user.setAddress(uaddress);
		user.setAge(Integer.parseInt(uage));
		//2.注册的业务
		UserService userService=new UserServiceImpl();
		boolean flag=userService.register(user);
		//3.根据业务的返回结果做响应
		if(flag){
			
		}else{
			
		}
	}
```

上面的servlet得到表单的数据,然后调用业务逻辑

UserService.java(业务接口)同上

```java
public interface UserService {
	//登录的业务接口方法
	public boolean login(User user);

	public boolean register(User user);

}
```
具体的注册逻辑接口的实现
UserServiceImpl.java

```java
@Override
	public boolean register(User user) {
		boolean flag=false;
		int rowAffect=userDao.register(user);
		if(rowAffect==1){
			flag=true;
		}
		return false;
	}
```

业务逻辑调用数据库数据
数据库访问层接口
userDao.java

```java
public interface UserDao {
	//登陆的数据库方法
	public int login(User user);
	//注册的数据库方法
	public int register(User user);
}
```

具体的实现  
userDaoImple.java

```java
@Override
	public int register(User user) {
		int rowAffect=0;
		try {
			String sql = "insert into t_user (username,userpassword,age,address) values(?,?,?,?)";
			rowAffect = CommonDao.executeUpdate(sql,
					new Object[] { user.getName(), user.getPassword(), user.getAge(), user.getAddress() });
		} catch (Exception e) {
			// TODO: handle exception
		}
		return rowAffect;
	}
```

### 总结
数据的轮回如下

 浏览器-->Servlet-->业务逻辑层-->数据访问层(数据)-->  
 -->数据访问层(数据)-->业务逻辑层-->Servlet-->浏览器  
最终响应在浏览器上  

## 数据库操作

数据库(CommonDao)的操作在jdbc讲过,为了更方便的修改不同的数据库,此项目用PropertyUtil方式
下面是通用的连接数据库操作
CommonDao.java

```java
public class CommonDao {
	private static PropertyUtil pu=new PropertyUtil("mysql.properties");
	private static String driverClass=pu.getProperty("jdbc_driverClass");
	private static String url=pu.getProperty("jdbc_url");
	private static String username=pu.getProperty("jdbc_username");
	private static String userpassword=pu.getProperty("jdbc_userpassword");
	/**
	 * 获取连接的公共方法
	 * @return
	 * @throws Exception
	 */
	public static Connection getConnection()throws Exception{
		Connection con=null;
		Class.forName(driverClass);
		con=DriverManager.getConnection(
				url,
				username,
				userpassword);
		return con;
	}
}
```

定义mysql属性文件  
mysql.properties

```text
jdbc_driverClass=com.mysql.jdbc.Driver
jdbc_url=jdbc:mysql://localhost:3306/testdb
jdbc_username=root
jdbc_userpassword=root
```

propertyUtil得到这个属性文件,然后通过文件中的属性名来得到具体的值,这样通过修改属性文件中的属性值就可以连接不同的数据库