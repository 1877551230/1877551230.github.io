---
layout:     post
title:      
subtitle:   
date:       2019-07-16
categories: Java
author:     miracle
catalog: true
tags:
    - JavaAPI
---
* content
{:toc}

## Object类api
 是所有类的根类,此类中放置了一些常用api方法,这些api是所有的类都需要使用的
- getClass()
获取指定对象的Class类型的对象
- equals(Object)
判断地址
- hashCode()
返回指定对象的哈希值
- toString()
输出对象的类型+@哈希值,如果两个对象相同,说明是一个对象,只占用一份内存空间,输出的哈希值是一样的  
system.out.println(对象名);等价于system.out.println(对象名.toString());
- finalize
在gc收集对象之前会自动调用此方法,在此方法中可以自定义对象的释放原则,是某个类重写此法方法,只能在gc收集这个类的对象的时候,才会调用,程序员是无法掌控何时gc   **final和finally和finalize的区别**:
1. final
修饰在方法上,就是常量  
修饰在方法上不能被重写
修饰在类上,不能被继承
2. finally
在异常处理中用于释放资源的
3. finalize
在gc收集对象前,调用此方法

- String
1. java.lang.String使用final修饰的类,不能被继承
2. 字符串底层封装的是字符数组以及操作字符数组的api方法
3. 字符串一旦创建,对象将无法更改,但字符串的引用是可以重新赋值的
4. java字符串采用的是Unicode编码

- String常量池
1. java为了提高性能,静态的字符串(字面量,常量)在常量池中创建,并尽量使用同一个对象重用静态字符串
2. 对于重复出现的字符串,jvm会首先在常量池中查找,如果存在就返回该对象
比如:String str1="abc";//abc字符串放置到常量池中,在栈中引用是str1  
在另一个作用域中,String str2="abc";abc在常量池中寻找是否有相同的字符串,如果有就指向它,没有就在常量池中添加

## String的常用的api方法

- indexOf方法
用户在字符串中检索另一个字符串(从前往后找)
 1. int indexOf(String str)
 在字符串中检索str,返回第一次出现的位置,如果没有找到就返回-1
 2. int indexOf(String str,int fromIndex)
 从fromIndex位置开始检索str
- lastIndexOf方法
用户在字符串中检索另一个字符串(从后往前找)
 1. int lastIndexOf(String str)
 在字符串中检索str,返回第一次出现的位置,如果没有找到就返回-1
 2. int lastIndexOf(String str,int fromIndex)
 从fromIndex位置开始检索str
 indexof和lastIndexOf方法返回的结果都是整数,找到字符串的位置,没找到返回-1

- subString方法 用于返回一个字符串的子字符串
 String subString(int beginIndex,int endIndex),左闭右开  
 String subString(int beginIndex),从beginIndex开始一直到末尾

- trim方法,用于去掉字符串两边的空格
 String trim();
- charAt方法 返回指定位置的字符
 char charAt(int index);  
 如果超出范围会报数组下标越界异常  
 StringIndexOurOfBoundException
- startWith方法 检测一个字符串是否以自定的字符串开头
 boolean startsWith(String str)
- endsWith方法 检测一个字符串是否以指定的字符串为尾部
 boolean endsWith(String str)
- toUpperCase方法,转换字符串中的所有字符为大写
- toLowerCase方法,转换字符串中的所有字符为小写
- valueOf方法 将其他类型转换为字符串类型(静态方法)
- splite方法,根据指定的规则拆分字符串
 String[] split(String str)
- equals方法,判断内容,因为重写了Object的equals方法
- equalsIgnoreCase方法,忽略大小写比较内容
- StringBuilder类
 封装的是可变字符串,对象创建后,可以通过调用本类的api方法,改变其封装的字符串序列  
 StringBuilder append(String str);//追加字符串  
 StringBuilder insert(int destOffset,String str);//插入字符串  
 StringBuilder delete(int start,int end);//删除指定开始和结束的字符串(左闭右开)  
 StringBuilder replace(int start,int end,String str);
 StringBuilder reverse();//字符串反转  
 **方法链:**
  方法的返回值都是本类对象就可以用方法链
  比如
```java
  StringBuilder sb = new StringBuilder("abc");
  sb.append("de").insert(2,"哈哈");
  //结果是ab哈哈cde
```
- StringBuffer类
 StringBUffer和StringBuilder类用法基本相同  

### String,StringBuilder和StringBuf的区别

String字符串列表不可变,里面的字符数组是final  
StringBuilder和StringBuffer都是字符串系列可以改变  
StringBuilder线程不安全,异步,速度快  
StringBuffer线程安全,同步,速度慢  
如果频繁对字符串的内容做增删改,首选StringBuilder或StringBuffer  
如果字符串内容不改变,首选String

## 封装类
| 基本数据类型 | 封装数据类型 |
| :----- |:--- |
| byte | Byte |
| char | Character |
| short | Short |
| int | Integer |
| long | Long |
| float | Float |
| double | Double |
| boolean | Boolean |
| void | Void |

### 为什么使用封装类

 8种基本数据类型,给指定的基本数据类型存储完数据  
 基本数据类型不能通过方法来操作数据,不是面向对象的操作方式  
 封装类解决了这个问题,先把数据存储给封装类对象,然后通过打点调用方法,通过方法可以对对象中的数据进行操作
 比如:
 
```java
Integer intObj = new Integer(10);
//把整型数据转换成字节
byte byteValue = intObj.byteValue();
```
不用面向对象的思维实现

```java
int i = 10;
byte byteValue = (byte)i;
```

## 拆箱和装箱
* 拆箱:把类类型拆开变成基本数据类型,即把对象中的数据拆出来变成基本数据类型的数据
* 装箱:是把基本数据类型的数据封装成对象数据

比如: 
* 一:

```java
Integer i = new Integer(3);//把基本数据类型数据3装箱成对象i
int ii = i.intValue();//把i对象中的数据3,转换成基本数据类型ii
```
* 二:

```java
Integer k=3;//装箱
int kk=k;//拆箱
```

方式一的写法在任意jre版本都能使用,方式二的写法只能在jre1.5及以上版本,此方式是属于自动装箱和拆箱,建议写第二种


