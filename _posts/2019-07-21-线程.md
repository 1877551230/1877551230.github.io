---
layout:     post
title:      线程
subtitle:   
date:       2019-07-21
categories: Java
author:     miracle
catalog: true
tags:
    - JavaAPI
    - Java多线程
---

* content
{:toc}

## 并发:
- 多个不用的软件同时运行  
 windows/linux操作系统,同时管理多个软件并发执行  
 eclipse,notepad++,游戏等软件同时运行
- 一个软件可以被多个用户同时请求  
 多个浏览器用户同时请求淘宝,做结算操作,支付操作,等价于 结算操作和支付操作,在服务端被多次运行 

**总结**  
 多个软件同时运行,一个软件被运行多次,cpu不停工作,提高cpu的利用率

### 计算机如果做到并发
 **前提**:  
 一台计算机,一块cpu,单核  
 **分析cpu**:  
 cpu的某个时间点,只能有一个程序执行  
 为了能做到并发,把cpu的时间分成若干时间片  
 时间片划分原则由操作系统来定义  
 每个小的时间片只能执行一个程序  
 时间片到了就把程序强制退出cpu  
 再从内存中选出下一个程序继续运行,以此往复  
 看似在一段时间内,是多个程序在同时运行  
 **分析软件**:  
 一个软件动辄几百兆或上G,一个软件是不能整个存储到内存中的  
## 进程:
 把大的软件分割成多个小的程序段,此程序段可以称为进程  
 多个大的程序要运行,先把程序分割成多个程序段  
 然后把每个程序的前一部分的若干程序段加载到内存  
 最终内存中放置了多个程序的多个程序段  
 这些程序段要根据优先级排队,cpu从队头获取下一个程序段来执行  
 大量的程序段/进程,在频繁切换cpu的时候会占用cpu的时间做压栈和弹栈的工作  
 和需要部分内存存储栈中的数据  
 **总结**:  
 要想做到并发,cpu要划时间片段,程序要划进程,由操作系统来划时间片和程序段  

## 线程:
 因为并发导致占用cpu时间和内存,那么就把进程再次划分为多个更小的程序片段,叫做线程thread  
 其实在cpu上来回切换的是线程,因为所有的线程共享进程的资源
 在进程中,包含的一个或多个线程是能够执行的独立的单元
 **结论:**  
 cpu划片段,程序划分进程段,进程段划分线程段,真正在cpu运行的是线程  
 尽量提高cpu利用率,减少使用内存  

 进程还拥有一个私有的虚拟的内存地址,该空间仅能被他包含的线程访问  
 线程只能归属某一个进程,并且只能访问该进程的所有资源  

 当操作系统创建了一个进程后,该进程就会自动申请一个名为主线程或者首要线程的线程  
 同类的多个线程共享一块内存空间和一组资源  
 线程本身有一个供程序执行堆栈,线程在cpu切换时负荷小,因此线程被称为轻负荷进程,一个进程可以包含多个线程
## 进程和线程的区别:
 一个进程至少有一个线程  
 线程的划分尺度小于进程,使得多个线程并发性高  
 进程在指定的过程中拥有独立的内存单元,而多个线程共享进程的内存空间  
 从而提高了程序的运行效率  

 线程在执行的过程中与进程区别在于每个独立的线程有一个程序的运行入口,顺序执行序列和程序出口  
 线程不能独立运行,必须在应用程序中,由应用程序提供对线程的控制

## 线程的应用场景

线程通常用于一个应用程序中需要同时完成多个任务的情况,我们可以将每个任务定义一个线程,使得它们得以一同工作  
也可以用于单一线程中完成,但是使用多线程可以更快的完成所需要的功能

## 线程的使用
 在java中,通过java的api做线程编程  
 方案一:继承Thread类

```java
/**
 * 创建线程方案一
 * 继承自Thread类
 */
public class MyThread extends Thread {

    public void run(){
        System.out.println("线程的入口"+Thread.currentThread().getName());
        System.out.println("MyThread1.run()-->线程的功能"+Thread.currentThread().getName());
        System.out.println("线程的出口"+Thread.currentThread().getName());
    }

     public static void main(String[] args) {
        //创建一个线程对象
        MyThread th1 = new MyThread();
        //th1.run();//可以调用run方法,但是不是线程并发,就是调用一个普通的方法
        //把th1线程放在内存中,但不一定马上调用run方法
        //th1线程获取到cpu则自动调用run方法
        th1.run();//不是并发
        th1.start();
        //创建线程对象,th2和th1是两个线程对象
        MyThread th2 = new MyThread();
        th2.run();//不是并发
        th2.start();
    }
}
```

 
 方案二:实现Runnable接口

```java
/**
 * 不是线程类,只是一个接口的子实现
 * 就是普通的一个实现类
 * 仅用于表达线程的逻辑
 * 用于把线程和线程的逻辑分离
 */
public class MyThread2 implements Runnable{


    @Override
    public void run() {
        System.out.println("线程的入口"+Thread.currentThread().getName());
        System.out.println("MyThread1.run()-->线程的功能"+Thread.currentThread().getName());
        System.out.println("线程的出口"+Thread.currentThread().getName());

    }
     public static void main(String[] args) {
        //此对象不是线程对象
        MyThread2 th = new MyThread2();
        //创建了一个线程对象t1
        Thread t1 = new Thread(th);
        t1.start();
        //创建了一个线程对象t2
        Thread t2 = new Thread(th);
        t2.start();

    }
}
```
 
### Thread类:
 此类是线程类,其每一个实例对象表示一个可以并发运行的线程,我们可以通过继承此类并重写run方法来定义一个具体的接口,在run方法中,体现的是现成的功能,(有线程的入口,线程的出口),启动线程时,调用线程对象的start方法,而不是直接调用run方法  
 start方法将线程纳入线程调度,适当前线程可以并发运行  
 当线程获取到cpu时间片后开始自动运行run方法中的逻辑代码
### Runnable接口
 实现此接口并重写run方法,来定义线程类,然后再创建线程的时候,将Runnable接口的实例传入并启动线程  
 这样做的好处:可以将线程和线程要执行的业务逻辑分离,减少耦合,同时java是单继承,定义一个实现Runnable接口,这样做可以更好地去实现其他接口和继承父类  
 做线程的目的实际上为了做多线程  
 做多线程的目的为了并发  
 并发的目的为了提高cpu的利用率

## 做多线程的两种方式
 1. 多个线程共享一个run
 2. 多个线程可以每个线程一个run 