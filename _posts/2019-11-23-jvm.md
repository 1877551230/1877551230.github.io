---
layout:     post
title:      jvm
subtitle:   
date:       2019-11-23
categories: Java
author:     miracle
catalog: true
tags:
    - jvm
---

* content
{:toc}


## 类的加载

类的加载指的是将类的class文件中的二进制数据读入到内存中,将其放在运行时数据区的方法区内,然后在堆区创建一个java.lang.class对象,用来封装类在方法区内的数据结构.类的加载的最终产品是位于堆内中的class对象,class对象封装了类在方法区内的数据结构,并且提供了方法区内的数据结构的接口.

## 类加载器

* bootstrap classloader启动类加载器
负责加载存放在jdk/jre/lib下,或被-xbootclasspath参数指定的路径中的,并且能被虚拟机识别的类库
* extclassloader扩展类加载器
该加载器由sun.misc.launcher$extclassloader实现,他负责加载jdk/jre/lib/ext目录中,或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.*开头的类)
* appclassloader应用类加载器
该加载器由sun.misc.launcher$extclassloader实现,他负责加载用户类路径所指定的类
* user classloader自定义类加载器

## jvm加载clasd文件的原理机制

jvm中的类的装载是由类加载器和他的子类来实现的,java中的类加载器是一个重要的java运行时系统组件,它负责在运行时查找和装入类文件中的类.  
由于java的跨平台,经过编译的java源程序并不是可执行程序,而是一个或多个类文件.当java程序需要使用某个类时,jvm会确保这个类已经被**加载**,**连接**和**初始化**.  

* 类的加载:是指类的.class文件中的数据读入内存中,通常是创建一个字节数据读入.class文件,然后产生与所加载类对应的class对象.加载完成后,class对象还不完整,所以此时类还不能用
* 当类被加载后就进入连接阶段,这个阶段包括验证,准备(为静态变量分配内存并设置默认初始值)和解析(将符号引用替换为直接引用)三个步骤.  
* 最后jvm对类进行初始化:1.如果类存在直接的父类并且这个类还没有被初始化,那么就先初始化父类2.如果类种存在初始化语句,就依次执行这些初始化语句.  

类的加载是由类加载器完成的,类的加载器包括:根加载器,扩展加载器,系统加载器和用户自定义类加载器  
从jdk1.2开始,类加载过程采取了父亲委托机制(pdm),pdm更好的保证了java平台的安全性,在该机制中,jvm自带的bootstrap是根加载器,其他的加载器都有且只有一个父类加载器.类的加载首先请求父类加载器加载,父类加载器无能为力时才由子类加载器自行加载.

## java对象创建过程

1. jvm遇到一条新建对象的指令时首先去检查这个指令的参数是否能在常量池定义到一个类的符号引用,然后加载这个类
2. 为对象分配内存.
3. 将除了对象头意外的对象空间初始化为0
4. 对对象头进行必要设置

## 类的声明周期

类的声明周期包括加载,连接,初始化,使用,卸载.  
加载,连接,初始化是类的加载过程

## java对象结构

java对象由三个部分组成:对象头,实例数据,对其填充  
* 对象头由两部分组成  
 1. 存储对象自身的运行时数据:hash码,gc分代年龄,锁标识状态,线程持有锁,偏向线程id
 2. 指针类型,指向对象的类的元数据类型.如果是数组对象,对象头中还有一部分用来记录数组长度
* 实例数据用来存储对象真正的有效信息
* 对齐填充:jvm要求对象的起始地址必须是8字节的整数倍(8字节对齐)

## java对象的定位方式

句柄池,直接指针

## 如何判断对象被回收
* 引用计数:每个对象有一个引用计数属性,新增一个引用时计数加1,引用释放时,技术为0时可以回收.无法解决对象相互引用的问题.
* 可达性分析:从gc roots开始向下搜索,搜索所走过的路径称为引用链.当一个对象从gc roots没有任何引用链相连时,则证明此对象是不可用的不可达对象

## jvm永久代中会发生垃圾回收吗

垃圾回收不会发生在永久代,如果永久代满了或者超出临界值,会触发完全回收(full gc).

## gc是什么

gc是垃圾收集,内存处理是编程人员容易出现问题的地方,忘记或者错误的内存回收会导致程序或系统的不稳定设置崩溃,java提供的gc功能可以自动检测对象是否超过作用域从而达到自动回收内存的目的,java语言没有提供释放已分配内存的显示操作方法.不用担心内存管理,因为垃圾收集器会自动管理.要请求垃圾收集,可以调用下面的方法之一:system.gc()或Runtime.getRuntime().gc(),但jvm可以屏蔽掉显示的垃圾回收调用.垃圾回收可以有效的防止内存泄漏,有效的使用可以使用的永存.垃圾回收器通常是作为一个单独的低优先级线程运行,不可预知的情况下对内存堆中已经死亡或长时间没有使用的对象进行清楚和回收,程序员不能实时的调用垃圾收集器对某个对象或者所有对象进行垃圾回收.在java诞生初期,垃圾回收是java最大的亮点之一,因为服务器端的编程需要有效的防止内存泄漏问题,而如今的java垃圾回收机制称为被诟病的东西.  

垃圾回收机制
1. 分代复制垃圾回收
2. 标记垃圾回收
3. 增量垃圾回收

* 伊甸园eden:对象最初诞生的区域,对大多数对象来说,这是唯一存在过的区域
* 幸存者乐园survivor:从伊甸园幸存下来的对象会被挪到这
* 终身颐养园tenured:这是足够老幸存对象归宿.年轻代收集minor-gc过程不会触及到这个地方.当年轻代收集不能把对象放进这里时,就会触发一次完全收集.

[垃圾收集机制详细](https://www.cnblogs.com/sunniest/p/4575144.html)