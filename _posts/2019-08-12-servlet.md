---
layout:     post
title:      Servlet
subtitle:   
date:       2019-08-12
categories: Java
author:     miracle
catalog: true
tags:
    - JavaWeb
---

* content
{:toc}


## web.xml:
web.xml文件存储在/webContent/WEB-INF/web.xml  
web.xml当前web项目的入口,即每一个web项目都要有一个web.xml文件  
web.xml在tomcat服务器启动的时候解析和加载,启动完毕后,改动了web.xml不会生效  
 解析:用dom4j能读取web.xml的内容  
 加载:解析完毕后把读取到的内容以字符串的方式存储到内存中  
 

## WEB-INF目录:
在webapp/WEB-INF目录
此目录中的所有资源,都不能通过浏览器来访问,但是程序可以访问,一些重要的页面可以放在里面

## tomcat启动过程:
 1. Initialzation processed in xx ms-->启动时首先解析和加载tomcat目录中的web.xml-->tomcat自检
 2. starting service Catalina-->正在开启服务
 3. starting servlet engine-->开启服务中的servlet引擎,引擎开启后,自动读取/加载/解析部署后的web项目的web.xml-->项目的web.xml检查
 4. Server startup in xxx ms-->启动完毕

## servlet
sun公司做出一套servlet规范(接口),此套规范无法独立运行,必须放在web服务器中(tomcat)中运行,web服务器(tomcat),也可以称为web容器(放置多个web项目),有了这个前提可以做到通过浏览器请求一个url地址,最终执行了某个servlet中的doXXX方法,即通过浏览器就可以执行一段java代码,这就是设计servlet接口的目的  
**多个平台之间调用的时候,可以模拟servlet接口**  

### 提交方式:
1. post(表单):
以数据块的方式发送数据给服务端,可以发送大量数据,在地址栏不会显示内容,安全.  
2. get(表单):
以数据字符串的方式发送给服务端,只能发送两百多字符,在地址栏上会显示数据内容,没有明确指定post提交,默认一律get提交

servlet运行的步骤:
1. 浏览器依据url建立与web服务器(tomcat)的连接
2. 浏览器对请求的数据打包并发送给服务器
3. 服务器解析请求的数据,并分别把数据封装到request对象和response对象
4. web应用服务器根据url的路径,寻找servlet并反射实例化servlet对象
5. web应用服务器调用init方法,做初始化
6. web应用服务器自动调用service方法,service方法根据method指定的值调用对应的doXXX方法
7. 执行doXXX方法,方法中通过response对象,把数据响应给浏览器
8. 浏览器获取到响应回来的数据(响应的实体内容),浏览器格式化显示数据到网页上

### servlet生命周期
web.xml部分代码:

```xml
<servlet>
  	<servlet-name>UserLoginServletName</servlet-name>
  	<servlet-class>cn.tedu.servlet.UserLoginServlet</servlet-class>
  	<!-- Object obj=Class.forName("cn.tedu.servlet.UserLoginServlet").newInstance(); -->
  </servlet>
  <servlet-mapping>
  	<servlet-name>UserLoginServletName</servlet-name>
  	<url-pattern>/login</url-pattern>
  </servlet-mapping>
```

浏览器请求某个url的时候,也就是在请求服务器中的servlet,如果web.xml中有此url,就寻找这个url的兄弟节点<servlet-name>,如果有,就取出名字,拿这个名字去整个web.xml文件中查找是否有<servlet><servlet-name><servlet-name/><servlet/>层级关系的servlet的名字,如果找到了就找<servlet-name>的兄弟节点<servet-class>,取出servlet-class的值,并反射实例化对象,此servlet生命周期开始,用此对象自动调用init方法(如果有),init方法只执行一次,并做相关的初始化工作;
然后自动调用service方法,service方法会根据method指定的值去调用对应的doXXX方法,只要服务器不停止,每次请求都会执行service方法,直到正常停止web应用服务器,会自动调用destroy方法,destroy方法用于销毁对象并释放内存空间,生命周期结束.

1. 第一次请求servlet的时候生命周期开始
2. 在服务器启动的时候生命周期开始

```xml
<servlet>  
	<load-on-startup>数字<load-on-startup/>  
</servlet>  
```
**load-on-startup**:    
- 此元素标记容器在启动的时候加载这个servlet,生命周期开始
- 它的值必须是一个整数,表示servlet加载的顺序,值大于等于0的时候表示容器在启动的时候加载,值小于0或没有配置此项表示容器在该servlet被第一次请求的时候加载,整数值越小,优先级越高,servlet就越是优先加载,当值相同的时候,容器就按照书写的顺序加载

### init()

每一次生命周期开始都调用此方法,一般做初始化工作  
有两种初始化方式:
 1. 局部初始化

```xml
 <servlet>
    <servlet-name>SysInitServletName</servlet-name>
    <servlet-class>cn.tedu.servlet.SysInitServlet</servlet-class>
    <init-param>
      <param-name>ipRange</param-name>
      <param-value>10.8.38.1-10.8.38.100</param-value>
    </init-param>
    <init-param>
      <param-name>encoding</param-name>
      <param-value>UTF-8</param-value>
    </init-param>
    <load-on-startup>0</load-on-startup>
  </servlet>
```
   初始化的数据仅在指定的servlet中使用  
 2. 全局初始化

```xml
    <web-app>  
	  	<context-param>
   			<param-name>globalIpRange</param-name>
    		<param-value>10.8.38.1-10.8.38.100</param-value>
  		</context-param>
  		<context-param>
   			<param-name>globalEncoding</param-name>
   			<param-value>UTF-8</param-value>
 		 </context-param> 
    <web-app/>
```  
   所有的servlet,filter,listener都可以读取初始化数据  
初始化方法有两个  
 1. init(); 无参数
 2. init(ServeletConfig);有参数  
 如果这两个方法同时存在,执行的是带参数的方法  
 
### service()

每次请求调用此方法,由此方法决定调用某个doXXX方法

### doXXX()
只做三件事

1. 获取前端提交的数据
2. 基于前端提交的数据调用具体业务
3. 根据业务的返回结果做响应给客户端

### destroy()

 方法中放置释放资源代码,对象=null;  
 在web容器正常停止时调用

## ServletContext(servlet上下文对象)

当tomcat启动的时候,先自检自己
自检完毕后starting service开启服务
staring servlet engine 开启servlet引擎
开始读取web容器中的web项目,逐一解析加载每一个web项目的web.xml
web容器(tomcat容器/web应用服务器)会为每一个web项目分配一个ServletContext,每一个web项目的ServletContext只有一个
tomcat停止服务,web项目的ServletContext就销毁了
ServletContext是一个对象,存储在tomcat容器中,是服务端对象,ServletContext对象中维护了多个map集合,可以把数据存储给ServletContext对象中,供所有的Servlet,filter,listener访问

### 获取ServletContext对象的方式
1. 在servlet类中的任意方法中写this.getServletContext();
2. 用ServletConfig对象.getServletContext();
3. 用request.getSession().getServletContext();
4. 用过滤器中的带参数的init方法,FilterConfig对象.getServletContext();

## ServletConfig(servlet的配置对象)

在Servlet中的有参数的init()方法,参数就是ServletConfig  
ServletConfig对象.getInitParameter("key");//获取局部参数  
ServletConfig对象.getServletContext().getInitParameter();获取全局初始化数据  
ServletConfig对象中存储的是当前的servlet的信息,servletConfig对象只对应一个servlet
ServletConfig对象中能存储什么数据,ServletConfig.getXXX()

## http协议(HyperText Transfer Protocal超文本传输协议)
 有w3c指定的一种应用层面的协议,用来定义浏览器与web服务器之间如何通信以及通信的数据格式  
 当请求服务器的资源时,会根据http协议发送一些数据(消息头,请求头,发送的数据)  
 服务器接收到后,会拆开数据,服务器根据拆开的数据做服务器的处理,处理完后给响应给浏览器(响应头和响应体内容)
 消息头,请求头,发送的数据,响应头,响应的内容都要遵守http协议,否则http协议无法识别这些信息  
 每一种浏览器都可以查看http协议的信息,也可以借助第三方工具postman等  

**请求的数据包组成**:  
- 请求行:请求的方式+请求的资源路径+协议版本
- 消息头:消息头中包含键值对,一般由w3c定义,通信双方通过消息头内容传递信息
- 实体内容:只有请求的方式是post,实体内容才会有数据
**响应的数据包组成**:  
- 状态行:协议的类型+版本+状态码+状态码描述
- 消息头:web服务器返回的一些消息头给浏览器
- 实体内容:服务器返回的结果

servlet如何处理http协议  
 当web容易受到一个http请求时,通信数据由web容器负责封装和提供这些信息,这些信息分为两个对象  
 与请求数据对应的是HTTPServletRequest接口类型的对象  
 与响应数据对应的是HttpServletResponse接口类型的对象  

**HTTPServletRequest对象**  
 当客户端通过http协议访问服务器的时候,请求中所有的消息信息都封装到这个对象中,通过此对象,getXXX方法获取协议中的消息信息
 比如:  
 getParameter("key");  
 getRemoteAddr();  
 ...  

**HTTPServletResponse对象**
 提供给客户端响应数据,封装了http响应的数据,通过这个对象可以设置状态行消息头和实体内容  
 比如:  
 响应的内容为png图像  
 response.setContentType("image/png");  
 设置响应的内容是utf-8格式:  
 response.setCharacterEncoding("UTF-8");  
 设置响应到浏览器的页面:  
 response.sendRedirect("login.jsp");  
 ...  

## 转发和重定向

### 重定向
response.sendRedirect("可以是jsp,也可以是servlet的url");  
 相当于重新请求服务器资源(jsp,servlet)  
 request对象和response对象都是servlet容器新创建的对象  
 地址栏会显示重定向后的连接(url)  
 服务器象浏览器发送一个302状态码以及一个location的消息头  
 该消息头的值是一个地址,称之为重定向地址,浏览器收到后会立即向location中标记的地址发出请求
### 转发
 request.getRequestDispatcher(可以是jsp,也可以是servlet).forward(request,response);
 转发实际上就是请求指定jsp或servlet,也会跳转到指定目的地,相当于请求服务器资源,就是在服务器中请求服务器中的另一份资源,就是在服务器内部跳转,request对象和response对象都是原来的对象,不会新创建,如果request对象绑定了数据,转发就是把数据转发的下一个目标中,地址栏的内容不是目的地址,原来地址栏是什么,就是什么,即地址的地址不变,不带数据的转发,没有任何意义,用重定向即可  
转发的步骤:
1. 给request绑定数据
request.setAttribute("key",value);  
2. 把绑定了数据的request对象转到以一个目标
request.getRequestDispatcher(目标url).forword(request,response);

## web开发中的乱码处理

1. 所有的乱码都可以用下面的方式处理
汉字=new String(乱码的字节,"UTF-8");  
比如:  
String 乱码=request.getParameter("userName");  
汉字=new String(乱码.getBytes("ISO8859-1"),"UTF-8");  
ISO8859-1也可以写成ISO-8859-1  
2. 下面的方法虽然代码简洁.但只有post提交的时候才生效
如果是get方式提交,下面的的语句不好使,此时只能方式一  
request.setCharacterEncoding("UTF-8");  
**注意:**第一种和第二种不要同时使用  

### tomcat版本问题

tomcat8版本及以后版本只需要使用方案二即可
方案一废弃不用,因为tomcat已经给实现处理了

* tomcat7版本及以前版本无论get提交还是post提交,request中都是ISO8859-1  
* tomcat8版本及以后版本  
get提交request中还是ISO8859-1,但getParameter取出数据就变成utf-8;  
post提交request中还是ISO8859-1,但取出的还是ISO8859-1  

## jstl(java/jsp的标准标签库)
是sun公司定义的一套标准,成为javaee5.0的核心
### 如何使用jstl
   在官网下载jstl开发包,把jstl.jar拷贝到项目中,然后构建路径
   在需要的jsp页面上写taglib指令
   <%@ taglib prefix="c" url="jstl的命名空间"%>
### jstl标签分类:
   核心标签库  简称 c 常用标签  
   <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>  
   格式化标签库  简称 fmt  
   <%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %>  
   sql标签库   简称sql  
   <%@ taglib prefix="sql" uri="http://java.sun.com/jsp/jstl/sql" %>  
  
大部分情况下使用核心标签  
  分支标签:  
  
```jsp
   <c:if test="" var="" scope="">
   </c:if>
```   

当test条件为true时,执行标签体的内容  
var:指定一个对象名称,此对象名称由用户定义  
scope:指定绑定数据的范围  
page,request,session,application  
	      
```jsp
   <c:choose>
	<c:when test="">   </c:when>
	...
	<c:when test="">   </c:when>
	<c:otherwise ></c:otherwise >
   </c:choose>

  <c:forEach var="" items="" varStatus="">
  </c:forEache>
```
| 属性 | 描述 | 是否必要 | 默认值 |
| :------ |:--- | :--- | :--- |
| items | 要被循环的信息 | Four | 无 |
| begin | 开始的元素(0=第一个元素,1=第二个元素) | 否 | 0 |
| end | 最后一个元素(0=第一个元素,1=第二个元素) | 否 | Last element |
| step | 每一次迭代的步长 | 否 | 1 |
| var | 代表当前条目的变量名称 | 否 | 无 |
| varStatus | 代表循环状态的变量名称 | 否 | 无 |


## session

**session会话做了两件事**  
1. 标识session事哪个客户端
2. 基于同一个客户端,可以共享数据
3. session对象存在于服务器端
4. 是服务端的资源(servlet,jsp)访问,服务端的session对象  

**session对象是何时创建的**  
一定要注意:不是浏览器客户端访问应用服务器就有session对象  
**session对象是否被创建**:  
1. 请求头中如果没有JSESSIONID,那么就说明在服务端  
  没有session对象,是可以创建session对象了  
2. 请求头中有一个JSESSIONID  
   a.如果服务端有一个session的id值与JSESSIONID的值相同,就不创建,直接使用服务端的session对象  
   b.如果服务端没有与JSESSIONID的值相同的session id就新创建一个session对象  
	 
**session对象如何创建**  
在servlet中第一次使用下面语句创建session  
HttpSession session=request.getSession();等同于request.getSession(true);创建session对象  
如果第一访问一个jsp文件,服务端会自动创建一个session对象  
因为在jsp文件中有page指令 <% page  session="true"%> 默认创建一个session对象  

注意第二次访问servlet 和jsp不会创建session对象了,直接使用之前的session对象  
	 
**项目如何使用session对象:**  
在ServletA中  

```java  
HttpSesson session=request.getSession();  
session.setAttribute("page",page);//绑定数据session对象  
```
在servletB中  

```java
HttpSesson session=request.getSession();  
Object page=session.getAttribute("page");  
```
**session对象的销毁**  
1. 给session对象设置存活时间,如果不设置默认30分钟,1800秒  
  session.setMaxInactiveInterval(1000);   //1000秒  
2. session.invalidate();  

**session是如何记录是哪一个浏览器客户端:**  
如果服务器端创建了一个session对象,服务端会把生成的sessionID用Cookie响应给浏览器,基于当前浏览器,发送任何请求,浏览器都在请求头中,设置key和value  
JSESSIONID=服务端创建的sessionID

**用java代码清除session**:
  1. 清除session对象
session.invalidate();  
相当于清除session中的所有数据  
  2. session对象没有销毁,但清除sessoin中的数据  
session.removeAttribte(key);  
等同于  
session.setAttribute(key,null);  

**session的常用的api:**
 * session.getSession();//获取或创建session
 * session.setInactiveInterval(1000);//设置session最大的非活动时间
 * session.setAttribute(key ,value);//绑定数据给session对象
 * session.getAttribute(key);//从session中取出指定的数据
 * session.removeAttibute(key);//从session中清除指定的key的数据
  
**设置sesion的存活时间**:
1. 代码方式
session.setMaxInactiveInterval(1000);//秒为单位  
2. 用web.xml配置,以分钟为单位,

```xml
	  <session-config>
       <session-timeout>10</session-timeout>
      </session-config>
```
**session的优缺点:**  
* 优点:
安全性较高(存储到服务器上)  
session能保存的数据更丰富,cookie只能保存字符串  
session能够保存更多的数据,cookie只能保存4kb数据
* 缺点:
session将状态保存到服务器上,占用服务器内存,如果并发量高,会严重拖慢服务器的速度 
  
**开发servlet常见的错误**
 * 404是客户端请求服务端的资源不存在
 * 405错误web服务器无法定位doXXX方法
 * 500错误:全都是服务端的java代码错误(间接或直接)
 * 200是请求和响应成功
 * 302是重定向的时候响应的状态码  
  
## ajax:
什么是ajax:(Asynchronous javascript and xml)  
ajax是一种用来改善用户体验的技术,其实质上是使用XMLHttpRequest对象异步的向服务器发送请求.  
服务器返回部分数据,而不是返回并刷新整个页面,以页面无刷新的效果更新页面中的局部内容  

ajax提高的页面的交互度,提高了用户的体验度  
减少网络流量  
### 一.原生ajax的用法
  步骤如下:
1. html页面或jsp页面中出发某个事件,调用js方法  
2. 编写js方法  
 * a.创建XMLHttpRequest对象  
-ie浏览器器  
-非ie浏览器  
 * b.调用open方法  
参数1:提交的方式  
参数2:提交到服务器url  
参数3:true异步,false同步  
 * c.给XMLHttpRequest对象注册onreadystatechange事件  
判断readyState的值是4,和status的是值是200,然后  
获取服务端传递回来的xml或json或文本,然后dom编程  
更改html页面或jsp页面的局部内容  
 * d.如果是post提交,还要添加一个消息头  
xmlHttpRequest.setRequestHeader("content-type","application/x-www-form-urlencoded");  
	   
 * e.调用send方法发送请求  
  	   
如何获取,创建ajax对象(XMLHttpRequest对象)

```js
    var xmlHttpRequest;
    function createXMLHttpReqest(){
		if(window.XMLHttpRequest){
			//非ie浏览器
			xmlHttpRequest=new XMLHttpRequest();
		}else{
			//ie浏览器
			xmlHttpRequest=new ActiveXObject("Miscrosoft.XMLHTTP");
		}
	}
	等价于
	function createXMLHttpReqest(){
		if("ActiveXObject" in window || window.ActiveXObject){
			//ie浏览器
			xmlHttpRequest=new ActiveXObject("Miscrosoft.XMLHTTP");
		}else{
			//非ie浏览器
			xmlHttpRequest=new XMLHttpRequest();
		}
	}
```	
**介绍xmlHttpRequest对象的属性和方法**
* abort()  取消请求  xmlHttpRequest.abort();
* getAllResponseHeader();获取响应的所有的http头信息
* getReponseHeader();获取指定http头
* open(method,url,异步/同步) 创建请求
* send()   发送请求
* setRequestHeader()  设置请求http头
* onreadystatechange 发生任何状态的变化时的事件
* readyState:请求的状态
 * 0:尚未初始化  
 * 1:正在发送请求  
 * 2:请求完成  
 * 3:请求成功,正在接收数据  
 * 4:接收数据成功  
* status:服务端返回的http请求,响应回来状态码  
 * 200:成功  
 * 400:错误的请求  
 * 404:资源未找到  
 * 405:service方法调用错误  
 * 500:服务端java代码异常  
**注意**  
 readyState==4 && status==200时才成功  
responseText 服务端返回的文本  
responseXML  服务端返回的xml  
	
**调用open方法**  
1. 请求方式get  
xmlHttpRequest.open("get","XXXServlet",true);  
true:异步  
false:同步  
 
2. 请求方式是post  
xmlHttpRequest.open("post","XXXServlet",true);  
xmlHttpRequest.setRequestHeader("content-type","applicatoin/x-www-form-urlencoded");  
注意:  
setRequestHeader的作用:因为http协议要求发送post请求时,必须有content-type消息头,但默认情况ajax对象不会添加该
消息头,所以需要调用此方法添加消息头  
发送请求:  
get方式:xmlHttpRequest.send(null);  
post方式:xmlHttpRequest.send(name=value&name1=value1...);  
  
注意写法:  
post方式传递数据到服务器用send方法传递参数  
get方式传递数据到服务器用法:  
xmlHttpRequest.open("get","xxxServlet?name=value&name1=value1",true);  
用ajax对象给服务器传递数据时,如果参数中带有中文,可以能会有乱码  

### 二.jquery的ajax用法
1. **load()方法**:将服务器返回的数据字节添加到符合的的节点之上  
**语法:**
$obj.load(请求的地址,请求的参数);  
**请求的参数**:  
**方式一:**  
"username=tom&age=22"  
**方式二**:  
{"username":"tom","age":22}  
有请求参数时,load方法发送post请求,否则发送get请求  
2. **get()方法:发送get请求 ** 
**语法**:  
$.get(请求的地址,请求的参数,回调函数,服务器返回的数据类型);
**说明**:
回调函数添加的参数时服务器返回的数据  
**服务器返回的数据类型**:  
html:html文本  
text:文本  
json:json的数据  
xml:xml的数据  
script:javascript脚本  
3. **post()方法:发送post请求**  
**语法:**  
$.post(请求的地址,请求的参数,回调函数,服务器返回的数据类型);  
**说明:**
  回调函数添加的参数时服务器返回的数据  
**服务器返回的数据类型:**
html:html文本  
text:文本  
json:json的数据  
xml:xml的数据  
script:javascript脚本  

4. **ajax()方法**:发送异步提交
**语法:**  
$.ajax({});  
说明:{}内可以设置的选项参数  
- url:请求的地址
- type:请求的方式(get,post,put,delete等)
- data:请求的参数
- dataType:服务器返回的数据类型
- success:服务器处理正常对应的回调函数
- error:服务器出错对应的回调函数
- async:true(缺省),当值为false时发送同步请求	  