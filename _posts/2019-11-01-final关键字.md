---
layout:     post
title:      final关键字
subtitle:   
date:       2019-11-01
categories: Java
author:     miracle
catalog: true
tags:
    - 面试题
---

* content
{:toc}

## final关键字
1. 修饰类:  
表示类不可被继承  
2. 修饰方法:  
表示方法不可以被重写,可以重载  
3. 修饰变量:  
 * 修饰成员变量:如果final修饰的是类变量,只能在静态初始化中指定初始值或者声明该类变量时指定初始值,如果修饰的是成员变量,可以在非静态初始化块,声明该变量或者构造器中执行初始值
 * 修饰局部变量:系统不会为局部变量初始化,局部变量必须由程序员显示初始化.如果开始没有赋值,后面只能赋值一次.

```java
public class Test {
	final static int a=0;//必须赋值
	public static void main(String[] args) {
		final int b;
		b=0;//只能赋值一次
		//b=1;
		final int[] arr={1,2};
		arr[0]=1;//合法
		//arr=null;不合法
		final Person p=new Person("2");
		p.setName("1");//合法
		//p=null不合法
	}
}
```

## final和static的区别

static左右与成员变量用来只保存一份副本,而final的作用是用来保证变量不可变

## 为什么局部内部类和匿名内部类只能访问final变量

因为生命周期的原因。方法中的局部变量，方法结束后这个变量就要释放掉，final保证这个变量始终指向一个对象。首先，内部类和外部类其实是处于同一个级别，内部类不会因为定义在方法中就会随着方法的执行完毕而跟随者被销毁。问题就来了，如果外部类的方法中的变量不定义final，那么当外部类方法执行完毕的时候，这个局部变量肯定也就被GC了，然而内部类的某个方法还没有执行完，这个时候他所引用的外部变量已经找不到了。如果定义为final，java会将这个变量复制一份作为成员变量内置于内部类中，这样的话，由于final所修饰的值始终无法改变，所以这个变量所指向的内存区域就不会变。 为了解决：局部变量的生命周期与局部内部类的对象的生命周期的不一致性问题
