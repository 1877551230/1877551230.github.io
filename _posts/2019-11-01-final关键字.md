---
layout:     post
title:      final关键字
subtitle:   
date:       2019-11-01
categories: 面试题
author:     miracle
catalog: true
tags:
    - final关键字
---

* content
{:toc}

## final关键字
1. 修饰类:  
表示类不可被继承  
2. 修饰方法:  
表示方法不可以被重写,可以重载  
3. 修饰变量:  
 * 修饰成员变量:如果final修饰的是类变量,只能在静态初始化中指定初始值或者声明该类变量时指定初始值,如果修饰的是成员变量,可以在非静态初始化块,声明该变量或者构造器中执行初始值
 * 修饰局部变量:系统不会为局部变量初始化,局部变量必须由程序员显示初始化.如果开始没有赋值,后面只能赋值一次.

```java
public class Test {
	final static int a=0;//必须赋值
	public static void main(String[] args) {
		final int b;
		b=0;//只能赋值一次
		//b=1;
		final int[] arr={1,2};
		arr[0]=1;//合法
		//arr=null;不合法
		final Person p=new Person("2");
		p.setName("1");//合法
		//p=null不合法
	}
}
```

## final和static的区别

static左右与成员变量用来只保存一份副本,而final的作用是用来保证变量不可变

## 为什么局部内部类和匿名内部类只能访问final变量

因为生命周期的原因。方法中的局部变量，方法结束后这个变量就要释放掉，final保证这个变量始终指向一个对象。首先，内部类和外部类其实是处于同一个级别，内部类不会因为定义在方法中就会随着方法的执行完毕而跟随者被销毁。问题就来了，如果外部类的方法中的变量不定义final，那么当外部类方法执行完毕的时候，这个局部变量肯定也就被GC了，然而内部类的某个方法还没有执行完，这个时候他所引用的外部变量已经找不到了。如果定义为final，java会将这个变量复制一份作为成员变量内置于内部类中，这样的话，由于final所修饰的值始终无法改变，所以这个变量所指向的内存区域就不会变。 为了解决：局部变量的生命周期与局部内部类的对象的生命周期的不一致性问题

## finalize
在gc收集对象之前会自动调用此方法,在此方法中可以自定义对象的释放原则,是某个类重写此法方法,只能在gc收集这个类的对象的时候,才会调用,程序员是无法掌控何时gc   

## final和finally和finalize的区别
1. final
修饰在静态方法上,就是常量  
修饰在方法上不能被重写
修饰在类上,不能被继承
2. finally
在异常处理中用于释放资源的
3. finalize
在gc收集对象前,调用此方法
