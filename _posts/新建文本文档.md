jdk1.5新特性:
## 自动拆箱和装箱
## 增强for循环
可变参数:
 - 用...来定义
 - 本质是一个数组
 - 可以传入任意个参数
 - 可变参数只能放在方法参数的最后一个位置

静态导入
 - 用import static 包名.类名.静态属性名或静态方法名
 - 可以提高加载效率
 - 降低了可读性,建议慎用

## 枚举(enum)

 当取值为几个(有限)固定的值,可以使用枚举类型  
 枚举是一个数据类型
 普通的枚举
  public enum requestMethod{
	GET,POST,DELETE,PUT
	
  }
  public enum Week{
	Monday,
	Tuesday,
	Wednesday,
	Thursday,
	Friday,
	Saturday,
	Sunday
  }
 枚举也可以有方法和属性和构造方法,但是构造方法必须是私有的  
 枚举还可以实现接口,不能继承,枚举也可以包含抽象方法  
 所有自定义的枚举都默认继承自java.lang.Enum类  
 String name();
 int ordinal();

## 反射
 java中的提供的一套类库,通过这套类库可以  
 - 运行时动态获取类中的信息  
 - 运行时动态的调用构造函数,创建对象
 - 运行时动态的访问(调用)对象的方法和属性
这种运行期间动态获取类中的信息(属性,方法,包,注解等),以及动态调用对象的方法和属性的功能称为java的反射机制  
通俗理解:在运行期间,对类的内容进行操作  

### Class类
要想使用反射,就要获取到类中的所有信息(属性,方法等...)  
在java中,有一个特殊的类类型是Class,此类型的对象中存储的是某个类中的信息  
比如:  
 Class clazz1 = Class.forName("cn.tedu.Student");  
 clazz1是一个对象,此对象中存储的都是数据,这些数据都是Student中的属性和方法  
  属性:访问修饰符,类型,属性名  
  方法:访问修饰符,返回类型,方法名(参数列表)  
  Class Clazz2 = Class.forName("cn.tedu.User");  
  Clazz2也是一个对象,对象中存储的是User类中的属性和方法  
  
Class类是java提供的,这个Class类可以表达任意一个类的信息(属性,方法等类中的信息)
- 每个类加载后(方法区),系统都会为该类生成一个对应的Class类类型的对象,这个对象是存储在堆区中,通过该Class对象,可以访问方法区类中的信息
- 一旦获取了某个类Class类型的对象之后,程序员可以写程序调用Class对象中的api方法,获取给Class对象中的类的信息

### 如何获取Class类型的对象

- 对象.getClass();
比如  
User user=new User();  
Class clazz1 = user.getClass();  
- 类名.Class  
比如  
有一个类是User类型  
Class clazz = User.class;  
- Class.forName("包名.类名");  
比如  
 Class clazz1 = Class.forName("cn.miralce.User")  
 此种情况分为两步  
  1. 加载类User,进方法区,创建Class类型的对象
  2. 把返回Class类型的对象

用以上的三种方式,可以获取到Class类型的对象  
通过Class类型的对象获取如下:  
 - Filed类  
  代表成员变量,即属性  
 - Method类  
  代表方法  
 - Constructor类  
  代表构造函数  
 - Annotation类  
  代表注解  


通过上面的类的api获取对应的信息
- 可以获取Field中的信息,获取类的属性,属性的修饰符,属性的类型,属性的名称
- 可以获取Method中的信息,获取类的方法,修饰符,返回类型,方法名,参数列表
- 可以获取Constructor中的信息,获取构造函数,修饰符,参数列表
- 可以获取Annotation中的信息,获取注解,获取注解的名称,注解属性值  
结论:在运行期间,通过Class对象调用反射的api,可以反射实例化对象,可以反射访问属性和反射调用方法,总之,编译期间能写的代码,用反射也能实现.
